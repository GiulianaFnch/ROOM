<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>SYSTEM FAILURE - CRITICAL ERROR</title>
    <style>
        body { 
            margin: 0; 
            background-color: #050505; 
            overflow: hidden; 
            font-family: 'Courier New', monospace;
            user-select: none; /* Impede selecionar texto */
        }
        
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
            image-rendering: pixelated; 
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d8d8d8;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none; 
            opacity: 0.9;
            width: 300px;
            mix-blend-mode: exclusion;
            transition: opacity 0.2s;
        }
        
        .scanline {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 10;
        }

        /* BARRA DE PROGRESSO */
        #barra-container {
            width: 100%;           
            height: 15px;           
            background-color: #333; 
            border: 1px solid #555;
            margin-top: 10px;      
            position: relative;     
            overflow: hidden;       
        }

        #barra-progresso {
            height: 100%;
            width: 0%;              
            background-color: #ff3333; 
            transition: width 0.1s linear; 
        }

        #texto-porcentagem {
            position: absolute;
            width: 100%;
            top: 0;
            left: 0;
            line-height: 15px;     
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            color: #fff;            
            letter-spacing: 2px;
        }

        /* --- EFEITOS DE GLITCH E CRASH --- */
        
        /* Classe que será adicionada ao BODY para o glitch visual */
        .glitch-mode {
            animation: shake 0.1s infinite, color-cycle 0.05s infinite;
            filter: contrast(200%) hue-rotate(90deg);
        }

        @keyframes shake {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-10px, 10px); }
            50% { transform: translate(10px, -10px); }
            75% { transform: translate(-10px, -10px); }
            100% { transform: translate(10px, 10px); }
        }

        @keyframes color-cycle {
            0% { filter: invert(0%); }
            50% { filter: invert(100%); }
            100% { filter: invert(0%); }
        }

        /* A Tela Azul/Preta da Morte */
        #crash-screen {
            display: none; /* Escondido por padrão */
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #0000aa; /* Azul clássico de erro ou #000 para terror */
            color: #fff;
            z-index: 9999;
            padding: 50px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            cursor: none; /* Esconde o mouse */
        }

    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div class="scanline"></div>

    <div id="ui-layer">
        <div>BIO-SIGN: <span id="status" style="color: #33ff33">STABLE</span></div>
        <div style="font-size: 12px; margin-top: 5px;">CONTAINMENT INTEGRITY:</div>
        
        <div id="barra-container">
            <div id="barra-progresso"></div>
            <span id="texto-porcentagem">0%</span>
        </div>
    </div>

    <div id="crash-screen">
        <p>*** STOP: 0x000000D1 (0x0000000C, 0x00000002, 0x00000000, 0xF86B5A89)</p>
        <p>DRIVER_IRQL_NOT_LESS_OR_EQUAL</p>
        <br>
        <p>A fatal exception 0E has occurred at 0028:C0011E36 in VXD VMM(01) + 00010E36.</p>
        <p>The current application will be terminated.</p>
        <br>
        <p>> SIGNAL LOSS DETECTED.</p>
        <p>> CONTAINMENT BREACH CONFIRMED.</p>
        <p>> SYSTEM HALTED.</p>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- VARIÁVEIS ---
        let score = 0;
        const cliquesParaQuebrar = 20; 
        let isGameOver = false;
        
        const barraElement = document.getElementById('barra-progresso');
        const textoPorcentagemElement = document.getElementById('texto-porcentagem');
        const statusText = document.getElementById('status');
        const uiLayer = document.getElementById('ui-layer');

        // --- SETUP THREE.JS ---
        const RENDER_WIDTH = 320;
        const RENDER_HEIGHT = 240;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050705, 0.15); 
        scene.background = new THREE.Color(0x050705);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(RENDER_WIDTH, RENDER_HEIGHT, false);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.BasicShadowMap;
        document.body.appendChild(renderer.domElement);

        const raycaster = new THREE.Raycaster();
        const mouseVector = new THREE.Vector2();

        // --- ÁUDIO (Simulador de Som de Erro) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playGlitchSound() {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
            
            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        // --- OBJETOS 3D ---
        function createNoiseTexture(colorBase) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size; height: size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorBase; ctx.fillRect(0,0,size,size);
            for(let i=0; i<400; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#000000' : '#332211';
                ctx.globalAlpha = 0.1 + Math.random() * 0.2;
                ctx.fillRect(Math.random()*size, Math.random()*size, Math.random()*2, Math.random()*2);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const wallMat = new THREE.MeshStandardMaterial({ map: createNoiseTexture('#2a2f2a'), roughness: 0.9 });
        const room = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 10), wallMat);
        room.scale.set(-1, 1, 1); room.receiveShadow = true; scene.add(room);
        
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshStandardMaterial({ map: createNoiseTexture('#1a1a1a') }));
        floor.rotation.x = -Math.PI / 2; floor.position.y = -4; floor.receiveShadow = true; scene.add(floor);

        // OVO
        function createAlienSkin() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#7a7060'; ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#4a2525'; ctx.globalAlpha = 0.5;
            for(let i=0; i<12; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*size, Math.random()*size);
                ctx.bezierCurveTo(Math.random()*size, Math.random()*size, Math.random()*size, Math.random()*size, Math.random()*size, Math.random()*size);
                ctx.stroke();
            }
            return new THREE.CanvasTexture(canvas);
        }
        const skinTexture = createAlienSkin();
        skinTexture.magFilter = THREE.NearestFilter;
        
        const eggGeo = new THREE.IcosahedronGeometry(0.8, 1); 
        const eggMat = new THREE.MeshStandardMaterial({
            map: skinTexture, bumpMap: skinTexture, bumpScale: 0.15,
            color: 0x4a6b2a, roughness: 0.4, flatShading: false
        });
        const pet = new THREE.Mesh(eggGeo, eggMat);
        pet.castShadow = true; scene.add(pet);

        // LUZES
        scene.add(new THREE.AmbientLight(0xffffff, 0.05));
        const flashlight = new THREE.SpotLight(0xffffee, 50);
        flashlight.angle = Math.PI / 6; flashlight.penumbra = 0.5; flashlight.decay = 2; flashlight.distance = 15;
        flashlight.castShadow = true; scene.add(flashlight); scene.add(flashlight.target);

        // --- INTERAÇÃO ---
        let swayX = 0, swayY = 0;
        let stressLevel = 0;

        document.addEventListener('mousemove', (event) => {
            if (isGameOver) return;
            mouseVector.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            mouseVector.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            swayX = (event.clientX - window.innerWidth / 2) / 200;
            swayY = (event.clientY - window.innerHeight / 2) / 200;
            
            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObject(pet);
            document.body.style.cursor = (intersects.length > 0) ? 'pointer' : 'default';
        });

        document.addEventListener('mousedown', () => {
            if (isGameOver) return; // Se travou, ignora cliques

            // Inicializa áudio no primeiro clique (necessário para navegadores)
            if (audioCtx.state === 'suspended') audioCtx.resume();

            raycaster.setFromCamera(mouseVector, camera);
            const intersects = raycaster.intersectObject(pet);

            if (intersects.length > 0) {
                stressLevel += 1.0; 
                statusText.innerText = "CRITICAL - IMPACT";
                statusText.style.color = "#ff0000";

                score++;
                let porcentagem = (score / cliquesParaQuebrar) * 100;

                if (porcentagem >= 100) {
                    porcentagem = 100;
                    startCrashSequence();
                }

                barraElement.style.width = porcentagem + '%';
                textoPorcentagemElement.innerText = Math.floor(porcentagem) + '%';
            } 
        });

        document.addEventListener('mouseup', () => {
             if(score < cliquesParaQuebrar && !isGameOver) {
                statusText.innerText = "STABILIZING...";
                statusText.style.color = "#ffff00";
             }
        });

        // --- SEQUÊNCIA DO FIM (GLITCH REALISTA) ---
        function startCrashSequence() {
            isGameOver = true;
            statusText.innerText = "SYSTEM FAILURE";
            document.body.style.cursor = 'none'; // Some com o mouse

            // 1. Momento de silêncio/congelamento (suspense)
            // Congela a animação (paramos de atualizar o render loop visualmente)
            cancelAnimationFrame(animationId); 

            setTimeout(() => {
                // 2. O GLITCH (0.5 segundos de caos)
                document.body.classList.add('glitch-mode');
                playGlitchSound(); // Barulho horrível
                
                // Pisca a lanterna loucamente
                flashlight.color.setHex(0xff0000);
                flashlight.intensity = 1000;
                renderer.render(scene, camera); // Renderiza uma última vez com luz estourada
                
                setTimeout(() => {
                    // 3. A TELA DA MORTE (Crash Final)
                    document.body.classList.remove('glitch-mode');
                    // Remove tudo da tela (canvas, ui)
                    document.body.innerHTML = ""; 
                    // Mostra a tela de erro falsa
                    const bsod = document.getElementById('crash-screen'); // Ops, removemos o innerHTML.
                    // Vamos recriar o BSOD ou melhor:
                    // Como limpei o body, vou injetar o HTML do erro agora.
                    
                    document.body.style.backgroundColor = "#0000aa";
                    document.body.innerHTML = `
                        <div style="padding: 40px; color: white; font-family: 'Courier New'; font-size: 20px;">
                            <p>*** STOP: 0x000000D1 (0x0000000C, 0x00000002, 0x00000000, 0xF86B5A89)</p>
                            <p>DRIVER_IRQL_NOT_LESS_OR_EQUAL</p>
                            <br>
                            <p>A fatal exception 0E has occurred at 0028:C0011E36 in VXD VMM(01) + 00010E36.</p>
                            <p>Current application will be terminated.</p>
                            <br>
                            <p>> SIGNAL LOST.</p>
                            <p>> SUBJECT D-20 ESCAPED.</p>
                            <p>Press any key to continue...</p>
                        </div>
                    `;
                    
                    // Tenta colocar em tela cheia para travar a visão do usuário
                    try {
                        document.documentElement.requestFullscreen().catch(e => console.log(e));
                    } catch(e) {}

                }, 400); // Tempo do glitch durar
            }, 1500); // Tempo congelado antes do glitch
        }

        // Loop principal
        const clock = new THREE.Clock();
        camera.position.z = 4; camera.position.y = 0.5;
        let animationId;

        function animate() {
            animationId = requestAnimationFrame(animate);
            if (isGameOver) return; // Se acabou, para de calcular

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            camera.position.x += (swayX - camera.position.x) * 0.05;
            camera.position.y += (-swayY - camera.position.y + 0.5) * 0.05;
            camera.lookAt(0, 0, 0);
            
            flashlight.position.copy(camera.position);
            flashlight.target.position.set(swayX * 2, -swayY * 2, 0);
            
            pet.position.y = Math.sin(time) * 0.2;
            pet.rotation.x += 0.002; pet.rotation.y += 0.005;

            if (stressLevel > 0) {
                pet.position.x = (Math.random() - 0.5) * 0.3; 
                pet.position.z = (Math.random() - 0.5) * 0.3;
                stressLevel -= delta * 2; 
            } else {
                pet.position.x = 0; pet.position.z = 0;
                statusText.innerText = "STABLE";
                statusText.style.color = "#33ff33";
            }

            if (Math.random() > 0.95) flashlight.intensity = Math.random() * 50;
            else flashlight.intensity = 50;

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>